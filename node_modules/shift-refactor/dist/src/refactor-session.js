"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefactorSession = void 0;
const shift_codegen_1 = __importStar(require("@jsoverson/shift-codegen"));
const debug_1 = __importDefault(require("debug"));
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const shift_ast_1 = require("shift-ast");
const shift_parser_1 = require("shift-parser");
const global_state_1 = require("./global-state");
const query_1 = require("./misc/query");
const types_1 = require("./misc/types");
const util_1 = require("./misc/util");
const waterfall_1 = require("./misc/waterfall");
const debug = debug_1.default('shift-refactor');
/**
 * The Shift Refactor class that manages
 *
 * @deprecated
 * This was the original interface for shift-refactor pre-1.0. It remains similarly usable but is no longer intended to be instantiated directly.
 * Extend the chainable interface when necessary and use refactor() to instantiate. If a use case is not covered, submit an issue.
 *
 * @internal
 */
class RefactorSession {
    constructor(sourceOrNodes, globalSession) {
        let nodes, tree;
        if (!globalSession) {
            if (typeof sourceOrNodes === 'string' || !util_1.isArray(sourceOrNodes))
                this.globalSession = new global_state_1.GlobalState(sourceOrNodes);
            else
                throw new Error('Only source or a single Script/Module node can be passed as input');
        }
        else {
            this.globalSession = globalSession;
        }
        if (util_1.isArray(sourceOrNodes)) {
            nodes = sourceOrNodes.filter((x) => typeof x !== 'string');
        }
        else {
            if (!util_1.isString(sourceOrNodes))
                nodes = [sourceOrNodes];
            else
                nodes = [this.globalSession.root];
        }
        this.nodes = nodes;
    }
    get root() {
        return this.globalSession.root;
    }
    get length() {
        return this.nodes.length;
    }
    $(querySessionOrNodes) {
        return this.subSession(querySessionOrNodes);
    }
    subSession(querySessionOrNodes) {
        const nodes = querySessionOrNodes instanceof RefactorSession
            ? querySessionOrNodes.nodes
            : util_1.findNodes(this.nodes, querySessionOrNodes);
        const subSession = new RefactorSession(nodes, this.globalSession);
        return subSession;
    }
    rename(selectorOrNode, newName) {
        const lookupTable = this.globalSession.getLookupTable();
        const nodes = util_1.findNodes(this.nodes, selectorOrNode);
        nodes.forEach((node) => {
            if (node.type === 'VariableDeclarator')
                node = node.binding;
            const lookup = lookupTable.variableMap.get(node);
            if (!lookup)
                return;
            this.renameInPlace(lookup[0], newName);
        });
        return this;
    }
    renameInPlace(lookup, newName) {
        if (!lookup || !newName)
            return;
        lookup.declarations.forEach(decl => (decl.node.name = newName));
        lookup.references.forEach(ref => (ref.node.name = newName));
    }
    delete(selectorOrNode = this.nodes) {
        const nodes = util_1.findNodes(this.nodes, selectorOrNode);
        if (nodes.length > 0) {
            nodes.forEach((node) => this.globalSession._queueDeletion(node));
        }
        return this.globalSession.conditionalCleanup();
    }
    replace(selectorOrNode, replacer) {
        const nodes = util_1.findNodes(this.nodes, selectorOrNode);
        const replacementScript = typeof replacer === 'string' ? shift_parser_1.parseScript(replacer) : null;
        const replaced = nodes.map((node) => {
            let replacement = null;
            if (util_1.isFunction(replacer)) {
                const rv = replacer(node);
                if (rv && rv instanceof Promise) {
                    throw new types_1.RefactorError(`Promise returned from replacer function, use .replaceAsync() instead.`);
                }
                if (util_1.isShiftNode(rv)) {
                    replacement = rv;
                }
                else if (util_1.isString(rv)) {
                    const returnedTree = shift_parser_1.parseScript(rv);
                    if (util_1.isStatement(node)) {
                        replacement = util_1.extractStatement(returnedTree);
                    }
                    else {
                        replacement = util_1.extractExpression(returnedTree);
                    }
                }
                else {
                    throw new types_1.RefactorError(`Invalid return type from replacement function: ${rv}`);
                }
            }
            else if (util_1.isShiftNode(replacer)) {
                replacement = util_1.copy(replacer);
            }
            else if (replacementScript) {
                if (util_1.isStatement(node)) {
                    replacement = util_1.copy(replacementScript.statements[0]);
                }
                else {
                    // if we have a directive, assume we parsed a single string and use it as a LiteralStringExpression
                    if (replacementScript.directives.length > 0) {
                        replacement = new shift_ast_1.LiteralStringExpression({ value: replacementScript.directives[0].rawValue });
                    }
                    else if (replacementScript.statements[0].type === 'ExpressionStatement') {
                        replacement = util_1.copy(replacementScript.statements[0].expression);
                    }
                }
            }
            if (node && replacement !== node) {
                this.globalSession._queueReplacement(node, replacement);
                return true;
            }
            else {
                return false;
            }
        });
        this.globalSession.conditionalCleanup();
        return replaced.filter((wasReplaced) => wasReplaced).length;
    }
    async replaceAsync(selectorOrNode, replacer) {
        const nodes = util_1.findNodes(this.nodes, selectorOrNode);
        if (!util_1.isFunction(replacer)) {
            throw new types_1.RefactorError(`Invalid replacer type for replaceAsync. Pass a function or use .replace() instead.`);
        }
        const promiseResults = await waterfall_1.waterfallMap(nodes, async (node, i) => {
            let replacement = null;
            const rv = await replacer(node);
            if (util_1.isShiftNode(rv)) {
                replacement = rv;
            }
            else if (util_1.isString(rv)) {
                const returnedTree = shift_parser_1.parseScript(rv);
                if (util_1.isStatement(node)) {
                    replacement = util_1.extractStatement(returnedTree);
                }
                else {
                    replacement = util_1.extractExpression(returnedTree);
                }
            }
            else {
                throw new types_1.RefactorError(`Invalid return type from replacement function: ${rv}`);
            }
            if (node && replacement !== node) {
                this.globalSession._queueReplacement(node, replacement);
                return true;
            }
            else {
                return false;
            }
        });
        this.globalSession.conditionalCleanup();
        return promiseResults.filter(result => result).length;
    }
    replaceRecursive(selectorOrNode, replacer) {
        const nodesReplaced = this.replace(selectorOrNode, replacer);
        this.globalSession.cleanup();
        if (nodesReplaced > 0)
            this.replaceRecursive(selectorOrNode, replacer);
        return this;
    }
    first() {
        return this.nodes[0];
    }
    findParents(selectorOrNode) {
        return this.globalSession.findParents(selectorOrNode);
    }
    prepend(selectorOrNode, replacer) {
        return this.globalSession.insert(selectorOrNode, replacer, false);
    }
    append(selectorOrNode, replacer) {
        return this.globalSession.insert(selectorOrNode, replacer, true);
    }
    query(selector) {
        return query_1.query(this.nodes, selector);
    }
    // alias for query because I refuse to name findOne()->queryOne() and I need the symmetry.
    find(selectorOrNode) {
        return this.query(selectorOrNode);
    }
    queryFrom(astNodes, selectorOrNode) {
        return util_1.isArray(astNodes)
            ? astNodes.map(node => query_1.query(node, selectorOrNode)).flat()
            : query_1.query(astNodes, selectorOrNode);
    }
    findMatchingExpression(sampleSrc) {
        const tree = shift_parser_1.parseScript(sampleSrc);
        if (tree.statements[0] && tree.statements[0].type === 'ExpressionStatement') {
            const sampleExpression = tree.statements[0].expression;
            const potentialMatches = this.query(sampleExpression.type);
            const matches = potentialMatches.filter((realNode) => fast_deep_equal_1.default(sampleExpression, realNode));
            return matches;
        }
        return [];
    }
    findMatchingStatement(sampleSrc) {
        const tree = shift_parser_1.parseScript(sampleSrc);
        if (tree.statements[0]) {
            const sampleStatement = tree.statements[0];
            const potentialMatches = this.query(sampleStatement.type);
            const matches = potentialMatches.filter((realNode) => util_1.isDeepSimilar(sampleStatement, realNode));
            return matches;
        }
        return [];
    }
    findReferences(node) {
        const lookup = this.globalSession.lookupVariable(node);
        return lookup.references;
    }
    findDeclarations(node) {
        const lookup = this.globalSession.lookupVariable(node);
        return lookup.declarations;
    }
    findOne(selectorOrNode) {
        const nodes = this.query(selectorOrNode);
        if (nodes.length !== 1)
            throw new Error(`findOne('${selectorOrNode}') found ${nodes.length} nodes. If this is intentional, use .find()`);
        return nodes[0];
    }
    closest(originSelector, closestSelector) {
        const nodes = util_1.findNodes(this.nodes, originSelector);
        const recurse = (node, selector) => {
            const parent = this.findParents(node)[0];
            if (!parent)
                return [];
            const matches = query_1.query(parent, selector);
            if (matches.length > 0)
                return matches;
            else
                return recurse(parent, selector);
        };
        return nodes.flatMap((node) => recurse(node, closestSelector));
    }
    cleanup() {
        this.globalSession.cleanup();
        return this;
    }
    print(ast) {
        const generator = new shift_codegen_1.FormattedCodeGen();
        return shift_codegen_1.default(ast || this.first(), generator);
    }
}
exports.RefactorSession = RefactorSession;
//# sourceMappingURL=refactor-session.js.map