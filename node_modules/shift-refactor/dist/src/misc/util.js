"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.identityLogger = exports.getRootIdentifier = exports.isDeepSimilar = exports.isMemberExpression = exports.isMemberAssignment = exports.buildParentMap = exports.extractExpression = exports.extractStatement = exports.findNodes = exports.isLiteral = exports.innerBodyStatements = exports.isNodeWithStatements = exports.forceIntoArray = exports.isStatement = exports.isShiftNode = exports.isArray = exports.isFunction = exports.isString = exports.copy = void 0;
const shift_ast_1 = require("shift-ast");
const shift_traverser_1 = __importDefault(require("shift-traverser"));
const query_1 = require("./query");
const types_1 = require("./types");
function copy(object) {
    return JSON.parse(JSON.stringify(object));
}
exports.copy = copy;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isFunction(input) {
    return typeof input === 'function';
}
exports.isFunction = isFunction;
function isArray(input) {
    return Array.isArray(input);
}
exports.isArray = isArray;
function isShiftNode(input) {
    return input && typeof input.type !== 'undefined';
}
exports.isShiftNode = isShiftNode;
function isStatement(input) {
    return input && input.type && input.type.match(/(Statement|Declaration)$/);
}
exports.isStatement = isStatement;
function forceIntoArray(input) {
    return isArray(input) ? input : [input];
}
exports.forceIntoArray = forceIntoArray;
function isNodeWithStatements(input) {
    return 'statements' in input;
}
exports.isNodeWithStatements = isNodeWithStatements;
function innerBodyStatements(input) {
    return 'body' in input ? input.body : input;
}
exports.innerBodyStatements = innerBodyStatements;
function isLiteral(input) {
    return (input &&
        input.type &&
        (input.type.match(/^Literal/) ||
            (input.type === 'UnaryExpression' && input.operand.type === 'LiteralNumericExpression')));
}
exports.isLiteral = isLiteral;
function findNodes(ast, input) {
    if (isString(input))
        return query_1.query(ast, input);
    else if (isArray(input)) {
        if (isString(input[0])) {
            return input
                .filter((x) => typeof x === 'string')
                .flatMap((x) => query_1.query(ast, x));
        }
        else {
            return input;
        }
    }
    else if (isShiftNode(input))
        return [input];
    else
        return [];
}
exports.findNodes = findNodes;
function extractStatement(tree) {
    // catch the case where a string was parsed alone and read as a directive.
    if (tree.directives.length > 0) {
        return new shift_ast_1.ExpressionStatement({
            expression: new shift_ast_1.LiteralStringExpression({
                value: tree.directives[0].rawValue,
            }),
        });
    }
    else {
        return tree.statements[0];
    }
}
exports.extractStatement = extractStatement;
function extractExpression(tree) {
    // catch the case where a string was parsed alone and read as a directive.
    if (tree.directives.length > 0) {
        return new shift_ast_1.LiteralStringExpression({
            value: tree.directives[0].rawValue,
        });
    }
    else {
        if (tree.statements[0].type === 'ExpressionStatement') {
            return tree.statements[0].expression;
        }
        else {
            throw new types_1.RefactorError(`Can't replace an expression with a node of type ${tree.statements[0].type}`);
        }
    }
}
exports.extractExpression = extractExpression;
function buildParentMap(tree) {
    const parentMap = new WeakMap();
    shift_traverser_1.default.traverse(tree, {
        enter: (node, parent) => {
            parentMap.set(node, parent);
        },
    });
    return parentMap;
}
exports.buildParentMap = buildParentMap;
function isMemberAssignment(node) {
    return node.type === 'StaticMemberAssignmentTarget' || node.type === 'ComputedMemberAssignmentTarget';
}
exports.isMemberAssignment = isMemberAssignment;
function isMemberExpression(node) {
    return node.type === 'StaticMemberExpression' || node.type === 'ComputedMemberExpression';
}
exports.isMemberExpression = isMemberExpression;
function isDeepSimilar(partial, actual) {
    let similar = false;
    if (partial === undefined)
        return true;
    if (partial === null && actual === null)
        return true;
    for (let key in partial) {
        if (isArray(partial[key])) {
            similar =
                key in actual && isArray(actual[key])
                    ? partial[key].length === 0
                        ? true
                        : isDeepSimilar(partial[key], actual[key])
                    : false;
        }
        else if (typeof partial[key] === 'object') {
            similar = key in actual ? isDeepSimilar(partial[key], actual[key]) : false;
        }
        else {
            similar = partial[key] === actual[key];
        }
        if (!similar)
            break;
    }
    return similar;
}
exports.isDeepSimilar = isDeepSimilar;
function getRootIdentifier(expr) {
    if (expr.type === 'IdentifierExpression') {
        return expr;
    }
    else {
        switch (expr.object.type) {
            case 'IdentifierExpression':
                return expr.object;
            case 'ComputedMemberExpression':
            case 'StaticMemberExpression':
                return getRootIdentifier(expr.object);
            default:
                throw new Error('Can not get the identifier associated with the passed expression.');
        }
    }
}
exports.getRootIdentifier = getRootIdentifier;
function identityLogger(x) {
    console.log(x);
    return x;
}
exports.identityLogger = identityLogger;
//# sourceMappingURL=util.js.map