"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalState = void 0;
const shift_codegen_1 = __importStar(require("@jsoverson/shift-codegen"));
const debug_1 = __importDefault(require("debug"));
const shift_parser_1 = require("shift-parser");
const shift_scope_1 = __importStar(require("shift-scope"));
const shift_traverser_1 = __importDefault(require("shift-traverser"));
const shift_validator_1 = __importDefault(require("shift-validator"));
const types_1 = require("./misc/types");
const util_1 = require("./misc/util");
/**
 * Global State object for a script. Manages the root node, insertions, deletions, and replacements. All queries start from a global state and subqueries are child nodes.
 *
 * @remarks
 *
 * Most users won't need to instantiate this directly. Access an instance via `.globalSession` on any refactor query instance.
 *
 * @public
 */
class GlobalState {
    constructor(sourceOrNode, config = {}) {
        this.autoCleanup = true;
        this.scopeMap = new WeakMap();
        this.scopeOwnerMap = new WeakMap();
        this.parentMap = new WeakMap();
        this.variables = new Set();
        this.dirty = false;
        this.replacements = new WeakMap();
        this.deletions = new WeakSet();
        this.insertions = new WeakMap();
        let tree;
        if (util_1.isString(sourceOrNode)) {
            try {
                tree = shift_parser_1.parseScript(sourceOrNode);
            }
            catch (e) {
                throw new types_1.RefactorError(`Could not parse passed source: ${e}`);
            }
        }
        else {
            tree = sourceOrNode;
        }
        this.root = tree;
        if (config.autoCleanup)
            this.autoCleanup = config.autoCleanup;
        this.rebuildParentMap();
        this.getLookupTable();
    }
    lookupScope(variableLookup) {
        if (util_1.isArray(variableLookup))
            variableLookup = variableLookup[0];
        if (util_1.isShiftNode(variableLookup))
            variableLookup = this.lookupVariable(variableLookup);
        return this.scopeMap.get(variableLookup);
    }
    findReferences(node) {
        const lookup = this.lookupVariable(node);
        return lookup.references;
    }
    findDeclarations(node) {
        const lookup = this.lookupVariable(node);
        return lookup.declarations;
    }
    getInnerScope(node) {
        return this.scopeOwnerMap.get(node);
    }
    lookupVariable(node) {
        const lookupTable = this.getLookupTable();
        if (util_1.isArray(node))
            node = node[0];
        let lookup;
        switch (node.type) {
            case 'AssignmentExpression':
            case 'VariableDeclarator':
                lookup = lookupTable.variableMap.get(node.binding);
                break;
            case 'AssignmentTargetIdentifier':
            case 'IdentifierExpression':
            case 'BindingIdentifier':
                lookup = lookupTable.variableMap.get(node);
                break;
            case 'ClassDeclaration':
            case 'ClassExpression':
            case 'FunctionDeclaration':
            case 'FunctionExpression':
                lookup = lookupTable.variableMap.get(node.name);
                break;
        }
        if (!lookup)
            throw new Error('Could not find reference to passed identifier. Ensure you are passing a valid Identifier node.');
        if (lookup.length > 1)
            throw new Error('When does this happen? Submit an issue with this case so I can handle it better.');
        return lookup[0];
    }
    lookupVariableByName(name) {
        const lookupTable = this.getLookupTable();
        const varSet = new Set();
        // @ts-ignore: Poking where I shouldn't
        for (let [lookup] of lookupTable.variableMap._.values()) {
            if (name === lookup.name)
                varSet.add(lookup);
        }
        return Array.from(varSet);
    }
    _queueDeletion(node) {
        this.isDirty(true);
        this.deletions.add(node);
    }
    _queueReplacement(from, to) {
        this.isDirty(true);
        this.replacements.set(from, to);
    }
    getLookupTable() {
        if (this.lookupTable)
            return this.lookupTable;
        const globalScope = shift_scope_1.default(this.root);
        this.lookupTable = new shift_scope_1.ScopeLookup(globalScope);
        this._rebuildScopeMap();
        return this.lookupTable;
    }
    _rebuildScopeMap() {
        const lookupTable = this.getLookupTable();
        this.scopeMap = new WeakMap();
        this.variables = new Set();
        const recurse = (scope) => {
            this.scopeOwnerMap.set(scope.astNode, scope);
            scope.variableList.forEach((variable) => {
                this.variables.add(variable);
                this.scopeMap.set(variable, scope);
            });
            scope.children.forEach(recurse);
        };
        recurse(lookupTable.scope);
    }
    isDirty(dirty) {
        if (dirty !== undefined)
            this.dirty = dirty;
        return this.dirty;
    }
    validate() {
        return shift_validator_1.default(this.root);
    }
    conditionalCleanup() {
        if (this.autoCleanup)
            this.cleanup();
        return this;
    }
    cleanup() {
        if (!this.isDirty())
            return this;
        const _this = this;
        const result = shift_traverser_1.default.replace(this.root, {
            leave: function (node, parent) {
                if (node.type === 'VariableDeclarationStatement') {
                    if (node.declaration.declarators.length === 0)
                        return this.remove();
                }
                if (_this.replacements.has(node)) {
                    const newNode = _this.replacements.get(node);
                    _this.replacements.delete(node);
                    return newNode;
                }
                if (_this.insertions.has(node)) {
                    if (util_1.isStatement(node)) {
                        const insertion = _this.insertions.get(node);
                        if ('statements' in parent) {
                            let statementIndex = parent.statements.indexOf(node);
                            if (insertion.after)
                                statementIndex++;
                            parent.statements.splice(statementIndex, 0, insertion.statement);
                            _this.insertions.delete(node);
                        }
                        else {
                            debug_1.default(`Tried to insert ${node.type} but I lost track of my parent block :-(`);
                        }
                    }
                    else {
                        debug_1.default(`Tried to insert a non-Statement (${node.type}). Skipping.`);
                    }
                }
                if (_this.deletions.has(node)) {
                    _this.replacements.delete(node);
                    this.remove();
                }
            },
        });
        this.lookupTable = undefined;
        this.rebuildParentMap();
        this.isDirty(false);
        this.root = result;
        return this;
    }
    insert(selectorOrNode, replacer, after = false) {
        const nodes = util_1.findNodes([this.root], selectorOrNode);
        let insertion = null;
        let getInsertion = (program, node) => {
            if (util_1.isFunction(program)) {
                const result = program(node);
                if (util_1.isShiftNode(result))
                    return result;
                return shift_parser_1.parseScript(result).statements[0];
            }
            else {
                if (insertion)
                    return util_1.copy(insertion);
                if (util_1.isShiftNode(program))
                    return util_1.copy(program);
                return (insertion = shift_parser_1.parseScript(program).statements[0]);
            }
        };
        nodes.forEach((node) => {
            if (!util_1.isStatement(node))
                throw new types_1.RefactorError('Can only insert before or after Statements or Declarations');
            this.isDirty(true);
            const toInsert = getInsertion(replacer, node);
            if (!util_1.isStatement(toInsert))
                throw new types_1.RefactorError('Will not insert anything but a Statement or Declaration');
            this.insertions.set(node, {
                after,
                statement: getInsertion(replacer, node),
            });
        });
        return this.conditionalCleanup();
    }
    findParents(selectorOrNode) {
        const nodes = util_1.findNodes([this.root], selectorOrNode);
        return Array.from(new Set(nodes.map(node => this.parentMap.get(node)).filter((node) => !!node)));
    }
    generate(ast) {
        if (this.isDirty())
            throw new types_1.RefactorError('refactor .print() called with a dirty AST. This is almost always a bug. Call .cleanup() before printing.');
        return shift_codegen_1.default(ast || this.root, new shift_codegen_1.FormattedCodeGen());
    }
    rebuildParentMap() {
        this.parentMap = util_1.buildParentMap(this.root);
    }
}
exports.GlobalState = GlobalState;
//# sourceMappingURL=global-state.js.map