import {default as codegen, FormattedCodeGen} from '@jsoverson/shift-codegen';
const {
  Seq,
} = require('@jsoverson/shift-codegen/dist/coderep.js');

export const print = prettyPrint;

type ShiftNode = {type: string};

export function prettyPrint(ast?: ShiftNode) {
  if (!ast) return '';
  return codegen(ast, new FormattedCodeGen());
}

export function printSummary(ast?: ShiftNode) {
  if (!ast) return '';
  class SummaryCodeGen extends FormattedCodeGen {
    sep(separator: any) {
      return super.sep(separator);
    }
    brace(rep: any, node: any, first: any, last: any, emptySep: any) {
      const brace = super.brace(rep, node);
      // Hacky way to remove line breaks without re-implementing more than I want.
      if (brace.expr && brace.expr.children) {
        if (brace.expr.children[0].constructor.name === 'Linebreak') brace.expr.children.shift();
      }
      return brace;
    }
    reduceFunctionBody() {
      return this.t(' ... ');
    }
    reduceClassDeclaration(node: any, x: any) {
      const seq = super.reduceClassDeclaration(node, x);
      seq.children.find((t: any) => t.token === '{}').token = '{ ... }';
      return seq;
    }
    reduceClassElement() {
      return new Seq([]);
    }
  }
  let src = codegen(ast, new SummaryCodeGen());
  return src.trim();
}

export function printTruncated(ast?: ShiftNode, length: number = 50, overflow: string = '...') {
  if (!ast) return '';
  const src = codegen(ast) as string;
  const summary = src.substring(0, length - overflow.length) + overflow;
  return summary;
}

export function printTerse(ast?: ShiftNode) {
  if (!ast) return '';
  const src = codegen(ast) as string;
  return src;
}

export function log(ast?: ShiftNode) {
  console.log(print(ast));
}

export function logTruncated(ast?: ShiftNode, length?: number, overflow?: string) {
  console.log(printTruncated(ast, length, overflow));
}

export function logTerse(ast?: ShiftNode) {
  console.log(printTerse(ast));
}
